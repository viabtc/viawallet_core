// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Aptos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright Â© 2017-2022 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Necessary fields to process a TransferMessage
public struct TW_Aptos_Proto_TransferMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Destination Account address (string)
  public var to: String = String()

  /// Amount to be transferred (uint64)
  public var amount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Necessary tag for type function argument
public struct TW_Aptos_Proto_StructTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address of the account
  public var accountAddress: String = String()

  /// Module name
  public var module: String = String()

  /// Identifier
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Necessary fields to process a TokenTransferMessage
public struct TW_Aptos_Proto_TokenTransferMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Destination Account address (string)
  public var to: String = String()

  /// Amount to be transferred (uint64)
  public var amount: UInt64 = 0

  /// token function to call, e.g BTC: 0x43417434fd869edee76cca2a4d2301e528a1551b1d719b75c350c3c97d15b8b9::coins::BTC
  public var function: TW_Aptos_Proto_StructTag {
    get {return _function ?? TW_Aptos_Proto_StructTag()}
    set {_function = newValue}
  }
  /// Returns true if `function` has been explicitly set.
  public var hasFunction: Bool {return self._function != nil}
  /// Clears the value of `function`. Subsequent reads from it will return its default value.
  public mutating func clearFunction() {self._function = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _function: TW_Aptos_Proto_StructTag? = nil
}

/// Necessary fields to process a CreateAccountMessage
public struct TW_Aptos_Proto_CreateAccountMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// auth account address to create
  public var authKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Necessary fields to process an OfferNftMessage
public struct TW_Aptos_Proto_OfferNftMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Receiver address
  public var receiver: String = String()

  /// Creator address
  public var creator: String = String()

  /// Name of the collection
  public var collectionName: String = String()

  /// Name of the NFT
  public var name: String = String()

  /// Property version (should be often 0)
  public var propertyVersion: UInt64 = 0

  /// Amount of NFT's to transfer (should be often 1)
  public var amount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Necessary fields to process an CancelOfferNftMessage
public struct TW_Aptos_Proto_CancelOfferNftMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Receiver address
  public var receiver: String = String()

  /// Creator address
  public var creator: String = String()

  /// Name of the collection
  public var collectionName: String = String()

  /// Name of the NFT
  public var name: String = String()

  /// Property version (should be often 0)
  public var propertyVersion: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Necessary fields to process an ClaimNftMessage
public struct TW_Aptos_Proto_ClaimNftMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender address
  public var sender: String = String()

  /// Creator address
  public var creator: String = String()

  /// Name of the collection
  public var collectionName: String = String()

  /// Name of the NFT
  public var name: String = String()

  /// Property version (should be often 0)
  public var propertyVersion: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_Aptos_Proto_NftMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nftTransactionPayload: TW_Aptos_Proto_NftMessage.OneOf_NftTransactionPayload? = nil

  public var offerNft: TW_Aptos_Proto_OfferNftMessage {
    get {
      if case .offerNft(let v)? = nftTransactionPayload {return v}
      return TW_Aptos_Proto_OfferNftMessage()
    }
    set {nftTransactionPayload = .offerNft(newValue)}
  }

  public var cancelOfferNft: TW_Aptos_Proto_CancelOfferNftMessage {
    get {
      if case .cancelOfferNft(let v)? = nftTransactionPayload {return v}
      return TW_Aptos_Proto_CancelOfferNftMessage()
    }
    set {nftTransactionPayload = .cancelOfferNft(newValue)}
  }

  public var claimNft: TW_Aptos_Proto_ClaimNftMessage {
    get {
      if case .claimNft(let v)? = nftTransactionPayload {return v}
      return TW_Aptos_Proto_ClaimNftMessage()
    }
    set {nftTransactionPayload = .claimNft(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_NftTransactionPayload: Equatable {
    case offerNft(TW_Aptos_Proto_OfferNftMessage)
    case cancelOfferNft(TW_Aptos_Proto_CancelOfferNftMessage)
    case claimNft(TW_Aptos_Proto_ClaimNftMessage)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_Aptos_Proto_NftMessage.OneOf_NftTransactionPayload, rhs: TW_Aptos_Proto_NftMessage.OneOf_NftTransactionPayload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.offerNft, .offerNft): return {
        guard case .offerNft(let l) = lhs, case .offerNft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cancelOfferNft, .cancelOfferNft): return {
        guard case .cancelOfferNft(let l) = lhs, case .cancelOfferNft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.claimNft, .claimNft): return {
        guard case .claimNft(let l) = lhs, case .claimNft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Input data necessary to create a signed transaction.
public struct TW_Aptos_Proto_SigningInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender Account address (string)
  public var sender: String = String()

  /// Sequence number, incremented atomically for each tx present on the account, start at 0 (int64)
  public var sequenceNumber: Int64 = 0

  public var transactionPayload: TW_Aptos_Proto_SigningInput.OneOf_TransactionPayload? = nil

  public var transfer: TW_Aptos_Proto_TransferMessage {
    get {
      if case .transfer(let v)? = transactionPayload {return v}
      return TW_Aptos_Proto_TransferMessage()
    }
    set {transactionPayload = .transfer(newValue)}
  }

  public var tokenTransfer: TW_Aptos_Proto_TokenTransferMessage {
    get {
      if case .tokenTransfer(let v)? = transactionPayload {return v}
      return TW_Aptos_Proto_TokenTransferMessage()
    }
    set {transactionPayload = .tokenTransfer(newValue)}
  }

  public var createAccount: TW_Aptos_Proto_CreateAccountMessage {
    get {
      if case .createAccount(let v)? = transactionPayload {return v}
      return TW_Aptos_Proto_CreateAccountMessage()
    }
    set {transactionPayload = .createAccount(newValue)}
  }

  public var nftMessage: TW_Aptos_Proto_NftMessage {
    get {
      if case .nftMessage(let v)? = transactionPayload {return v}
      return TW_Aptos_Proto_NftMessage()
    }
    set {transactionPayload = .nftMessage(newValue)}
  }

  /// Max gas amount that the user is willing to pay (uint64)
  public var maxGasAmount: UInt64 = 0

  /// Gas unit price - queried through API (uint64)
  public var gasUnitPrice: UInt64 = 0

  /// Expiration timestamp for the transaction, can't be in the past (uint64)
  public var expirationTimestampSecs: UInt64 = 0

  ///  Chain id 1 (mainnet) 32(devnet) (uint32 - casted in uint8_t later)
  public var chainID: UInt32 = 0

  ///  Private key to sign the transaction (bytes)
  public var privateKey: Data = Data()

  /// hex encoded function to sign, use it for smart contract approval (string)
  public var anyEncoded: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_TransactionPayload: Equatable {
    case transfer(TW_Aptos_Proto_TransferMessage)
    case tokenTransfer(TW_Aptos_Proto_TokenTransferMessage)
    case createAccount(TW_Aptos_Proto_CreateAccountMessage)
    case nftMessage(TW_Aptos_Proto_NftMessage)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_Aptos_Proto_SigningInput.OneOf_TransactionPayload, rhs: TW_Aptos_Proto_SigningInput.OneOf_TransactionPayload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transfer, .transfer): return {
        guard case .transfer(let l) = lhs, case .transfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenTransfer, .tokenTransfer): return {
        guard case .tokenTransfer(let l) = lhs, case .tokenTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createAccount, .createAccount): return {
        guard case .createAccount(let l) = lhs, case .createAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nftMessage, .nftMessage): return {
        guard case .nftMessage(let l) = lhs, case .nftMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Information related to the signed transaction
public struct TW_Aptos_Proto_TransactionAuthenticator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Signature part of the signed transaction (bytes)
  public var signature: Data = Data()

  /// Public key of the signer (bytes)
  public var publicKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Transaction signing output.
public struct TW_Aptos_Proto_SigningOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The raw transaction (bytes)
  public var rawTxn: Data = Data()

  //// Public key and signature to authenticate
  public var authenticator: TW_Aptos_Proto_TransactionAuthenticator {
    get {return _authenticator ?? TW_Aptos_Proto_TransactionAuthenticator()}
    set {_authenticator = newValue}
  }
  /// Returns true if `authenticator` has been explicitly set.
  public var hasAuthenticator: Bool {return self._authenticator != nil}
  /// Clears the value of `authenticator`. Subsequent reads from it will return its default value.
  public mutating func clearAuthenticator() {self._authenticator = nil}

  //// Signed and encoded transaction bytes.
  public var encoded: Data = Data()

  /// Transaction json format for api broadcasting (string)
  public var json: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authenticator: TW_Aptos_Proto_TransactionAuthenticator? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.Aptos.Proto"

extension TW_Aptos_Proto_TransferMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_TransferMessage, rhs: TW_Aptos_Proto_TransferMessage) -> Bool {
    if lhs.to != rhs.to {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Aptos_Proto_StructTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StructTag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_address"),
    2: .same(proto: "module"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.module) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.accountAddress, fieldNumber: 1)
    }
    if !self.module.isEmpty {
      try visitor.visitSingularStringField(value: self.module, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_StructTag, rhs: TW_Aptos_Proto_StructTag) -> Bool {
    if lhs.accountAddress != rhs.accountAddress {return false}
    if lhs.module != rhs.module {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Aptos_Proto_TokenTransferMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenTransferMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "amount"),
    3: .same(proto: "function"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._function) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    try { if let v = self._function {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_TokenTransferMessage, rhs: TW_Aptos_Proto_TokenTransferMessage) -> Bool {
    if lhs.to != rhs.to {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._function != rhs._function {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Aptos_Proto_CreateAccountMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAccountMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authKey.isEmpty {
      try visitor.visitSingularStringField(value: self.authKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_CreateAccountMessage, rhs: TW_Aptos_Proto_CreateAccountMessage) -> Bool {
    if lhs.authKey != rhs.authKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Aptos_Proto_OfferNftMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OfferNftMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiver"),
    2: .same(proto: "creator"),
    3: .same(proto: "collectionName"),
    4: .same(proto: "name"),
    5: .standard(proto: "property_version"),
    6: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.propertyVersion) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if self.propertyVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.propertyVersion, fieldNumber: 5)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_OfferNftMessage, rhs: TW_Aptos_Proto_OfferNftMessage) -> Bool {
    if lhs.receiver != rhs.receiver {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.name != rhs.name {return false}
    if lhs.propertyVersion != rhs.propertyVersion {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Aptos_Proto_CancelOfferNftMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelOfferNftMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiver"),
    2: .same(proto: "creator"),
    3: .same(proto: "collectionName"),
    4: .same(proto: "name"),
    5: .standard(proto: "property_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.propertyVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if self.propertyVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.propertyVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_CancelOfferNftMessage, rhs: TW_Aptos_Proto_CancelOfferNftMessage) -> Bool {
    if lhs.receiver != rhs.receiver {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.name != rhs.name {return false}
    if lhs.propertyVersion != rhs.propertyVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Aptos_Proto_ClaimNftMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClaimNftMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "creator"),
    3: .same(proto: "collectionName"),
    4: .same(proto: "name"),
    5: .standard(proto: "property_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.propertyVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if self.propertyVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.propertyVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_ClaimNftMessage, rhs: TW_Aptos_Proto_ClaimNftMessage) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.name != rhs.name {return false}
    if lhs.propertyVersion != rhs.propertyVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Aptos_Proto_NftMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NftMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offer_nft"),
    2: .standard(proto: "cancel_offer_nft"),
    3: .standard(proto: "claim_nft"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: TW_Aptos_Proto_OfferNftMessage?
        var hadOneofValue = false
        if let current = self.nftTransactionPayload {
          hadOneofValue = true
          if case .offerNft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nftTransactionPayload = .offerNft(v)
        }
      }()
      case 2: try {
        var v: TW_Aptos_Proto_CancelOfferNftMessage?
        var hadOneofValue = false
        if let current = self.nftTransactionPayload {
          hadOneofValue = true
          if case .cancelOfferNft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nftTransactionPayload = .cancelOfferNft(v)
        }
      }()
      case 3: try {
        var v: TW_Aptos_Proto_ClaimNftMessage?
        var hadOneofValue = false
        if let current = self.nftTransactionPayload {
          hadOneofValue = true
          if case .claimNft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.nftTransactionPayload = .claimNft(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.nftTransactionPayload {
    case .offerNft?: try {
      guard case .offerNft(let v)? = self.nftTransactionPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .cancelOfferNft?: try {
      guard case .cancelOfferNft(let v)? = self.nftTransactionPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .claimNft?: try {
      guard case .claimNft(let v)? = self.nftTransactionPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_NftMessage, rhs: TW_Aptos_Proto_NftMessage) -> Bool {
    if lhs.nftTransactionPayload != rhs.nftTransactionPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Aptos_Proto_SigningInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "sequence_number"),
    3: .same(proto: "transfer"),
    4: .standard(proto: "token_transfer"),
    5: .standard(proto: "create_account"),
    6: .standard(proto: "nft_message"),
    7: .standard(proto: "max_gas_amount"),
    8: .standard(proto: "gas_unit_price"),
    9: .standard(proto: "expiration_timestamp_secs"),
    10: .standard(proto: "chain_id"),
    11: .standard(proto: "private_key"),
    12: .standard(proto: "any_encoded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.sequenceNumber) }()
      case 3: try {
        var v: TW_Aptos_Proto_TransferMessage?
        var hadOneofValue = false
        if let current = self.transactionPayload {
          hadOneofValue = true
          if case .transfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transactionPayload = .transfer(v)
        }
      }()
      case 4: try {
        var v: TW_Aptos_Proto_TokenTransferMessage?
        var hadOneofValue = false
        if let current = self.transactionPayload {
          hadOneofValue = true
          if case .tokenTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transactionPayload = .tokenTransfer(v)
        }
      }()
      case 5: try {
        var v: TW_Aptos_Proto_CreateAccountMessage?
        var hadOneofValue = false
        if let current = self.transactionPayload {
          hadOneofValue = true
          if case .createAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transactionPayload = .createAccount(v)
        }
      }()
      case 6: try {
        var v: TW_Aptos_Proto_NftMessage?
        var hadOneofValue = false
        if let current = self.transactionPayload {
          hadOneofValue = true
          if case .nftMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transactionPayload = .nftMessage(v)
        }
      }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.maxGasAmount) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.gasUnitPrice) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.expirationTimestampSecs) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.chainID) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.anyEncoded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.sequenceNumber, fieldNumber: 2)
    }
    switch self.transactionPayload {
    case .transfer?: try {
      guard case .transfer(let v)? = self.transactionPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .tokenTransfer?: try {
      guard case .tokenTransfer(let v)? = self.transactionPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .createAccount?: try {
      guard case .createAccount(let v)? = self.transactionPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .nftMessage?: try {
      guard case .nftMessage(let v)? = self.transactionPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    if self.maxGasAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxGasAmount, fieldNumber: 7)
    }
    if self.gasUnitPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasUnitPrice, fieldNumber: 8)
    }
    if self.expirationTimestampSecs != 0 {
      try visitor.visitSingularUInt64Field(value: self.expirationTimestampSecs, fieldNumber: 9)
    }
    if self.chainID != 0 {
      try visitor.visitSingularUInt32Field(value: self.chainID, fieldNumber: 10)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 11)
    }
    if !self.anyEncoded.isEmpty {
      try visitor.visitSingularStringField(value: self.anyEncoded, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_SigningInput, rhs: TW_Aptos_Proto_SigningInput) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.transactionPayload != rhs.transactionPayload {return false}
    if lhs.maxGasAmount != rhs.maxGasAmount {return false}
    if lhs.gasUnitPrice != rhs.gasUnitPrice {return false}
    if lhs.expirationTimestampSecs != rhs.expirationTimestampSecs {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.anyEncoded != rhs.anyEncoded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Aptos_Proto_TransactionAuthenticator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionAuthenticator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_TransactionAuthenticator, rhs: TW_Aptos_Proto_TransactionAuthenticator) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Aptos_Proto_SigningOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_txn"),
    2: .same(proto: "authenticator"),
    3: .same(proto: "encoded"),
    4: .same(proto: "json"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawTxn) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authenticator) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encoded) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.json) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rawTxn.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTxn, fieldNumber: 1)
    }
    try { if let v = self._authenticator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.encoded.isEmpty {
      try visitor.visitSingularBytesField(value: self.encoded, fieldNumber: 3)
    }
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Aptos_Proto_SigningOutput, rhs: TW_Aptos_Proto_SigningOutput) -> Bool {
    if lhs.rawTxn != rhs.rawTxn {return false}
    if lhs._authenticator != rhs._authenticator {return false}
    if lhs.encoded != rhs.encoded {return false}
    if lhs.json != rhs.json {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
