// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Cardano.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A transaction output that can be used as input
public struct TW_Cardano_Proto_OutPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction ID
  public var txHash: Data = Data()

  /// The index of this output within the transaction
  public var outputIndex: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a token and an amount. Token is identified by PolicyID and name.
public struct TW_Cardano_Proto_TokenAmount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Policy ID of the token, as hex string (28x2 digits)
  public var policyID: String = String()

  /// The name of the asset (within the policy)
  public var assetName: String = String()

  /// The amount (uint256, serialized little endian)
  public var amount: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// One input for a transaction
public struct TW_Cardano_Proto_TxInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The UTXO
  public var outPoint: TW_Cardano_Proto_OutPoint {
    get {return _outPoint ?? TW_Cardano_Proto_OutPoint()}
    set {_outPoint = newValue}
  }
  /// Returns true if `outPoint` has been explicitly set.
  public var hasOutPoint: Bool {return self._outPoint != nil}
  /// Clears the value of `outPoint`. Subsequent reads from it will return its default value.
  public mutating func clearOutPoint() {self._outPoint = nil}

  /// The owner address (string)
  public var address: String = String()

  /// ADA amount in the UTXO
  public var amount: UInt64 = 0

  /// optional token amounts in the UTXO
  public var tokenAmount: [TW_Cardano_Proto_TokenAmount] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _outPoint: TW_Cardano_Proto_OutPoint? = nil
}

/// One output for a transaction
public struct TW_Cardano_Proto_TxOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Destination address (string)
  public var address: String = String()

  /// ADA amount
  public var amount: UInt64 = 0

  /// optional token amounts
  public var tokenAmount: [TW_Cardano_Proto_TokenAmount] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Collection of tokens with amount
public struct TW_Cardano_Proto_TokenBundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: [TW_Cardano_Proto_TokenAmount] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for simple Transfer tx
public struct TW_Cardano_Proto_Transfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Destination address as string
  public var toAddress: String = String()

  /// Change address
  public var changeAddress: String = String()

  /// Requested ADA amount to be transferred. Output can be different only in use_max_amount case.
  /// Note that Cardano has a minimum amount per UTXO, see TWCardanoMinAdaAmount.
  public var amount: UInt64 = 0

  /// Optional token(s) to be transferred
  /// Currently only one token type to be transferred per transaction is supported
  public var tokenAmount: TW_Cardano_Proto_TokenBundle {
    get {return _tokenAmount ?? TW_Cardano_Proto_TokenBundle()}
    set {_tokenAmount = newValue}
  }
  /// Returns true if `tokenAmount` has been explicitly set.
  public var hasTokenAmount: Bool {return self._tokenAmount != nil}
  /// Clears the value of `tokenAmount`. Subsequent reads from it will return its default value.
  public mutating func clearTokenAmount() {self._tokenAmount = nil}

  /// Request max amount option. If set, tx will send all possible amounts from all inputs, including all tokens; there will be no change; requested amount and token_amount is disregarded in this case.
  public var useMaxAmount: Bool = false

  /// Optional fee overriding. If left to 0, optimal fee will be calculated. If set, exactly this value will be used as fee.
  /// Use it with care, it may result in underfunded or wasteful fee.
  public var forceFee: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenAmount: TW_Cardano_Proto_TokenBundle? = nil
}

/// Register a staking key for the account, prerequisite for Staking.
/// Note: staking messages are typically used with a 1-output-to-self transaction.
public struct TW_Cardano_Proto_RegisterStakingKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Staking address (as string)
  public var stakingAddress: String = String()

  /// Amount deposited in this TX. Should be 2 ADA (2000000). If not set correctly, TX will be rejected. See also Delegate.deposit_amount.
  public var depositAmount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Deregister staking key. can be done when staking is stopped completely. The Staking deposit is returned at this time.
public struct TW_Cardano_Proto_DeregisterStakingKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Staking address (as string)
  public var stakingAddress: String = String()

  /// Amount undeposited in this TX. Should be 2 ADA (2000000). If not set correctly, TX will be rejected. See also RegisterStakingKey.deposit_amount.
  public var undepositAmount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Delegate funds in this account to a specified staking pool.
public struct TW_Cardano_Proto_Delegate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Staking address (as string)
  public var stakingAddress: String = String()

  /// PoolID of staking pool
  public var poolID: Data = Data()

  /// Amount deposited in this TX. Should be 0. If not set correctly, TX will be rejected. See also RegisterStakingKey.deposit_amount.
  public var depositAmount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Withdraw earned staking reward.
public struct TW_Cardano_Proto_Withdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Staking address (as string)
  public var stakingAddress: String = String()

  /// Withdrawal amount. Should match the real value of the earned reward.
  public var withdrawAmount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes a preliminary transaction plan.
public struct TW_Cardano_Proto_TransactionPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total coins in the utxos
  public var availableAmount: UInt64 = 0

  /// coins in the output UTXO
  public var amount: UInt64 = 0

  /// coin amount deducted as fee
  public var fee: UInt64 = 0

  /// coins in the change UTXO
  public var change: UInt64 = 0

  /// coins deposited (going to deposit) in this TX
  public var deposit: UInt64 = 0

  /// coins undeposited (coming from deposit) in this TX
  public var undeposit: UInt64 = 0

  /// total tokens in the utxos (optional)
  public var availableTokens: [TW_Cardano_Proto_TokenAmount] = []

  /// tokens in the output (optional)
  public var outputTokens: [TW_Cardano_Proto_TokenAmount] = []

  /// tokens in the change (optional)
  public var changeTokens: [TW_Cardano_Proto_TokenAmount] = []

  /// The selected UTXOs, subset ot the input UTXOs
  public var utxos: [TW_Cardano_Proto_TxInput] = []

  /// Optional error
  public var error: TW_Common_Proto_SigningError = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Input data necessary to create a signed transaction.
public struct TW_Cardano_Proto_SigningInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Available input UTXOs
  public var utxos: [TW_Cardano_Proto_TxInput] {
    get {return _storage._utxos}
    set {_uniqueStorage()._utxos = newValue}
  }

  /// Available private keys (double extended keys); every input UTXO address should be covered
  /// In case of Plan only, keys should be present, in correct number
  public var privateKey: [Data] {
    get {return _storage._privateKey}
    set {_uniqueStorage()._privateKey = newValue}
  }

  /// Later this can be made oneof if more message types are supported
  public var transferMessage: TW_Cardano_Proto_Transfer {
    get {return _storage._transferMessage ?? TW_Cardano_Proto_Transfer()}
    set {_uniqueStorage()._transferMessage = newValue}
  }
  /// Returns true if `transferMessage` has been explicitly set.
  public var hasTransferMessage: Bool {return _storage._transferMessage != nil}
  /// Clears the value of `transferMessage`. Subsequent reads from it will return its default value.
  public mutating func clearTransferMessage() {_uniqueStorage()._transferMessage = nil}

  /// Optional, used in case of Staking Key registration (prerequisite for Staking)
  public var registerStakingKey: TW_Cardano_Proto_RegisterStakingKey {
    get {return _storage._registerStakingKey ?? TW_Cardano_Proto_RegisterStakingKey()}
    set {_uniqueStorage()._registerStakingKey = newValue}
  }
  /// Returns true if `registerStakingKey` has been explicitly set.
  public var hasRegisterStakingKey: Bool {return _storage._registerStakingKey != nil}
  /// Clears the value of `registerStakingKey`. Subsequent reads from it will return its default value.
  public mutating func clearRegisterStakingKey() {_uniqueStorage()._registerStakingKey = nil}

  /// Optional, used in case of (re)delegation
  public var delegate: TW_Cardano_Proto_Delegate {
    get {return _storage._delegate ?? TW_Cardano_Proto_Delegate()}
    set {_uniqueStorage()._delegate = newValue}
  }
  /// Returns true if `delegate` has been explicitly set.
  public var hasDelegate: Bool {return _storage._delegate != nil}
  /// Clears the value of `delegate`. Subsequent reads from it will return its default value.
  public mutating func clearDelegate() {_uniqueStorage()._delegate = nil}

  /// Optional, used in case of withdraw
  public var withdraw: TW_Cardano_Proto_Withdraw {
    get {return _storage._withdraw ?? TW_Cardano_Proto_Withdraw()}
    set {_uniqueStorage()._withdraw = newValue}
  }
  /// Returns true if `withdraw` has been explicitly set.
  public var hasWithdraw: Bool {return _storage._withdraw != nil}
  /// Clears the value of `withdraw`. Subsequent reads from it will return its default value.
  public mutating func clearWithdraw() {_uniqueStorage()._withdraw = nil}

  /// Optional
  public var deregisterStakingKey: TW_Cardano_Proto_DeregisterStakingKey {
    get {return _storage._deregisterStakingKey ?? TW_Cardano_Proto_DeregisterStakingKey()}
    set {_uniqueStorage()._deregisterStakingKey = newValue}
  }
  /// Returns true if `deregisterStakingKey` has been explicitly set.
  public var hasDeregisterStakingKey: Bool {return _storage._deregisterStakingKey != nil}
  /// Clears the value of `deregisterStakingKey`. Subsequent reads from it will return its default value.
  public mutating func clearDeregisterStakingKey() {_uniqueStorage()._deregisterStakingKey = nil}

  /// Time-to-live time of the TX
  public var ttl: UInt64 {
    get {return _storage._ttl}
    set {_uniqueStorage()._ttl = newValue}
  }

  /// Optional plan, if missing it will be computed
  public var plan: TW_Cardano_Proto_TransactionPlan {
    get {return _storage._plan ?? TW_Cardano_Proto_TransactionPlan()}
    set {_uniqueStorage()._plan = newValue}
  }
  /// Returns true if `plan` has been explicitly set.
  public var hasPlan: Bool {return _storage._plan != nil}
  /// Clears the value of `plan`. Subsequent reads from it will return its default value.
  public mutating func clearPlan() {_uniqueStorage()._plan = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Result containing the signed and encoded transaction.
public struct TW_Cardano_Proto_SigningOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Encoded transaction bytes
  public var encoded: Data = Data()

  /// TxID, derived from transaction data, also needed for submission
  public var txID: Data = Data()

  /// Optional error
  public var error: TW_Common_Proto_SigningError = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.Cardano.Proto"

extension TW_Cardano_Proto_OutPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hash"),
    2: .standard(proto: "output_index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txHash) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.outputIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHash, fieldNumber: 1)
    }
    if self.outputIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.outputIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_OutPoint, rhs: TW_Cardano_Proto_OutPoint) -> Bool {
    if lhs.txHash != rhs.txHash {return false}
    if lhs.outputIndex != rhs.outputIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_TokenAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenAmount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "policy_id"),
    2: .standard(proto: "asset_name"),
    3: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.policyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.assetName) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.policyID.isEmpty {
      try visitor.visitSingularStringField(value: self.policyID, fieldNumber: 1)
    }
    if !self.assetName.isEmpty {
      try visitor.visitSingularStringField(value: self.assetName, fieldNumber: 2)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularBytesField(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_TokenAmount, rhs: TW_Cardano_Proto_TokenAmount) -> Bool {
    if lhs.policyID != rhs.policyID {return false}
    if lhs.assetName != rhs.assetName {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_TxInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "out_point"),
    2: .same(proto: "address"),
    3: .same(proto: "amount"),
    4: .standard(proto: "token_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outPoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tokenAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    if !self.tokenAmount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokenAmount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_TxInput, rhs: TW_Cardano_Proto_TxInput) -> Bool {
    if lhs._outPoint != rhs._outPoint {return false}
    if lhs.address != rhs.address {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.tokenAmount != rhs.tokenAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_TxOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "amount"),
    3: .standard(proto: "token_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tokenAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    if !self.tokenAmount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokenAmount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_TxOutput, rhs: TW_Cardano_Proto_TxOutput) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.tokenAmount != rhs.tokenAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_TokenBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenBundle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_TokenBundle, rhs: TW_Cardano_Proto_TokenBundle) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_Transfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "to_address"),
    2: .standard(proto: "change_address"),
    3: .same(proto: "amount"),
    4: .standard(proto: "token_amount"),
    5: .standard(proto: "use_max_amount"),
    6: .standard(proto: "force_fee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.changeAddress) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tokenAmount) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.useMaxAmount) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.forceFee) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 1)
    }
    if !self.changeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.changeAddress, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    try { if let v = self._tokenAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.useMaxAmount != false {
      try visitor.visitSingularBoolField(value: self.useMaxAmount, fieldNumber: 5)
    }
    if self.forceFee != 0 {
      try visitor.visitSingularUInt64Field(value: self.forceFee, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_Transfer, rhs: TW_Cardano_Proto_Transfer) -> Bool {
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.changeAddress != rhs.changeAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._tokenAmount != rhs._tokenAmount {return false}
    if lhs.useMaxAmount != rhs.useMaxAmount {return false}
    if lhs.forceFee != rhs.forceFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_RegisterStakingKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterStakingKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staking_address"),
    2: .standard(proto: "deposit_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stakingAddress) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.depositAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stakingAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingAddress, fieldNumber: 1)
    }
    if self.depositAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.depositAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_RegisterStakingKey, rhs: TW_Cardano_Proto_RegisterStakingKey) -> Bool {
    if lhs.stakingAddress != rhs.stakingAddress {return false}
    if lhs.depositAmount != rhs.depositAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_DeregisterStakingKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeregisterStakingKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staking_address"),
    2: .standard(proto: "undeposit_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stakingAddress) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.undepositAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stakingAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingAddress, fieldNumber: 1)
    }
    if self.undepositAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.undepositAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_DeregisterStakingKey, rhs: TW_Cardano_Proto_DeregisterStakingKey) -> Bool {
    if lhs.stakingAddress != rhs.stakingAddress {return false}
    if lhs.undepositAmount != rhs.undepositAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_Delegate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Delegate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staking_address"),
    2: .standard(proto: "pool_id"),
    3: .standard(proto: "deposit_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stakingAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.depositAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stakingAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingAddress, fieldNumber: 1)
    }
    if !self.poolID.isEmpty {
      try visitor.visitSingularBytesField(value: self.poolID, fieldNumber: 2)
    }
    if self.depositAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.depositAmount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_Delegate, rhs: TW_Cardano_Proto_Delegate) -> Bool {
    if lhs.stakingAddress != rhs.stakingAddress {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.depositAmount != rhs.depositAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_Withdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Withdraw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staking_address"),
    2: .standard(proto: "withdraw_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stakingAddress) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.withdrawAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stakingAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingAddress, fieldNumber: 1)
    }
    if self.withdrawAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.withdrawAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_Withdraw, rhs: TW_Cardano_Proto_Withdraw) -> Bool {
    if lhs.stakingAddress != rhs.stakingAddress {return false}
    if lhs.withdrawAmount != rhs.withdrawAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_TransactionPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_amount"),
    2: .same(proto: "amount"),
    3: .same(proto: "fee"),
    4: .same(proto: "change"),
    10: .same(proto: "deposit"),
    11: .same(proto: "undeposit"),
    5: .standard(proto: "available_tokens"),
    6: .standard(proto: "output_tokens"),
    7: .standard(proto: "change_tokens"),
    8: .same(proto: "utxos"),
    9: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.availableAmount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.change) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.availableTokens) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.outputTokens) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.changeTokens) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.utxos) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.deposit) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.undeposit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.availableAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.availableAmount, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 3)
    }
    if self.change != 0 {
      try visitor.visitSingularUInt64Field(value: self.change, fieldNumber: 4)
    }
    if !self.availableTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availableTokens, fieldNumber: 5)
    }
    if !self.outputTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputTokens, fieldNumber: 6)
    }
    if !self.changeTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changeTokens, fieldNumber: 7)
    }
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 8)
    }
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 9)
    }
    if self.deposit != 0 {
      try visitor.visitSingularUInt64Field(value: self.deposit, fieldNumber: 10)
    }
    if self.undeposit != 0 {
      try visitor.visitSingularUInt64Field(value: self.undeposit, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_TransactionPlan, rhs: TW_Cardano_Proto_TransactionPlan) -> Bool {
    if lhs.availableAmount != rhs.availableAmount {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.change != rhs.change {return false}
    if lhs.deposit != rhs.deposit {return false}
    if lhs.undeposit != rhs.undeposit {return false}
    if lhs.availableTokens != rhs.availableTokens {return false}
    if lhs.outputTokens != rhs.outputTokens {return false}
    if lhs.changeTokens != rhs.changeTokens {return false}
    if lhs.utxos != rhs.utxos {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_SigningInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utxos"),
    2: .standard(proto: "private_key"),
    3: .standard(proto: "transfer_message"),
    6: .standard(proto: "register_staking_key"),
    7: .same(proto: "delegate"),
    8: .same(proto: "withdraw"),
    9: .standard(proto: "deregister_staking_key"),
    4: .same(proto: "ttl"),
    5: .same(proto: "plan"),
  ]

  fileprivate class _StorageClass {
    var _utxos: [TW_Cardano_Proto_TxInput] = []
    var _privateKey: [Data] = []
    var _transferMessage: TW_Cardano_Proto_Transfer? = nil
    var _registerStakingKey: TW_Cardano_Proto_RegisterStakingKey? = nil
    var _delegate: TW_Cardano_Proto_Delegate? = nil
    var _withdraw: TW_Cardano_Proto_Withdraw? = nil
    var _deregisterStakingKey: TW_Cardano_Proto_DeregisterStakingKey? = nil
    var _ttl: UInt64 = 0
    var _plan: TW_Cardano_Proto_TransactionPlan? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _utxos = source._utxos
      _privateKey = source._privateKey
      _transferMessage = source._transferMessage
      _registerStakingKey = source._registerStakingKey
      _delegate = source._delegate
      _withdraw = source._withdraw
      _deregisterStakingKey = source._deregisterStakingKey
      _ttl = source._ttl
      _plan = source._plan
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._utxos) }()
        case 2: try { try decoder.decodeRepeatedBytesField(value: &_storage._privateKey) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._transferMessage) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._ttl) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._plan) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._registerStakingKey) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._delegate) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._withdraw) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._deregisterStakingKey) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._utxos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._utxos, fieldNumber: 1)
      }
      if !_storage._privateKey.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._privateKey, fieldNumber: 2)
      }
      try { if let v = _storage._transferMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._ttl != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._ttl, fieldNumber: 4)
      }
      try { if let v = _storage._plan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._registerStakingKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._delegate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._withdraw {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._deregisterStakingKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_SigningInput, rhs: TW_Cardano_Proto_SigningInput) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._utxos != rhs_storage._utxos {return false}
        if _storage._privateKey != rhs_storage._privateKey {return false}
        if _storage._transferMessage != rhs_storage._transferMessage {return false}
        if _storage._registerStakingKey != rhs_storage._registerStakingKey {return false}
        if _storage._delegate != rhs_storage._delegate {return false}
        if _storage._withdraw != rhs_storage._withdraw {return false}
        if _storage._deregisterStakingKey != rhs_storage._deregisterStakingKey {return false}
        if _storage._ttl != rhs_storage._ttl {return false}
        if _storage._plan != rhs_storage._plan {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Cardano_Proto_SigningOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encoded"),
    2: .standard(proto: "tx_id"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encoded) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encoded.isEmpty {
      try visitor.visitSingularBytesField(value: self.encoded, fieldNumber: 1)
    }
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 2)
    }
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Cardano_Proto_SigningOutput, rhs: TW_Cardano_Proto_SigningOutput) -> Bool {
    if lhs.encoded != rhs.encoded {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
